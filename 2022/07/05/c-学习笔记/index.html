<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="c++学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="c++学习笔记">
<meta property="og:url" content="http://example.com/2022/07/05/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="FisherYu626">
<meta property="og:description" content="c++学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/www98/AppData/Roaming/Typora/typora-user-images/image-20211018185259169.png">
<meta property="og:image" content="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/image-20220514170125341.png">
<meta property="og:image" content="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/798C7A2D023204559B62F88B54E35CBB.png">
<meta property="og:image" content="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/image-20220515104206498.png">
<meta property="og:image" content="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/1DBA188A576ED176E295873CC580363A.png">
<meta property="og:image" content="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.png">
<meta property="og:image" content="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/%E6%88%AA%E5%B1%8F2022-05-22%2016.29.46.png">
<meta property="article:published_time" content="2022-07-04T16:02:32.000Z">
<meta property="article:modified_time" content="2022-07-04T16:03:14.156Z">
<meta property="article:author" content="Fisher Yu">
<meta property="article:tag" content="c++笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/www98/AppData/Roaming/Typora/typora-user-images/image-20211018185259169.png">

<link rel="canonical" href="http://example.com/2022/07/05/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>c++学习笔记 | FisherYu626</title>
  


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9029be5f4e12ce010d95a037066e5a1b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="FisherYu626" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
    <div class="container use-motion">
      <div class="headband"></div>

      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">FisherYu626</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一颗有趣的灵魂~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/FisherYu626" class="github-corner" title="帅哥，快来玩啊~" aria-label="帅哥，快来玩啊~" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


      <main class="main">
        <div class="main-inner">
          <div class="content-wrap">
            

            <div class="content post posts-expand">
              

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/05/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/fisher.jpg">
      <meta itemprop="name" content="Fisher Yu">
      <meta itemprop="description" content="学习过程中的一些浅显summries,见谅!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FisherYu626">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          c++学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-05 00:02:32 / 修改时间：00:03:14" itemprop="dateCreated datePublished" datetime="2022-07-05T00:02:32+08:00">2022-07-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="c-学习笔记"><a href="#c-学习笔记" class="headerlink" title="c++学习笔记"></a>c++学习笔记</h1><span id="more"></span>
<h1 id="A-语法基础"><a href="#A-语法基础" class="headerlink" title="A.语法基础"></a>A.语法基础</h1><h2 id="1-宏定义："><a href="#1-宏定义：" class="headerlink" title="1.宏定义："></a>1.宏定义：</h2><p><img src="C:\Users\www98\AppData\Roaming\Typora\typora-user-images\image-20211018185259169.png" alt=""></p>
<p>宏替换发生的4种情况：</p>
<p>1.文件包含，将源程序中的#include扩展到文件中正文，将包含.h的文件展开到#include所在处</p>
<p>2.条件编译：预处理器根据#if和#ifdef等编译命令及其后的条件，将源程序中的某部分包含进来或排除在外，通常把排除在外的语句转换成空行。</p>
<p>3.宏展开：预处理器将源程序文件中出现的对宏的引用展开（替换）成相应的宏定义，即本文所说的#define的功能，由预处理器来完成。<br>  经过预处理器处理的源程序与之前的源程序有所有不同，在这个阶段所进行的工作只是纯粹的替换与展开，没有任何计算功能。</p>
<h2 id="2-C-接口（抽象类）"><a href="#2-C-接口（抽象类）" class="headerlink" title="2.C++ 接口（抽象类）"></a>2.C++ 接口（抽象类）</h2><p>如果一个类中至少包含一个纯虚函数，则这个类是一个抽象类。</p>
<p>纯虚函数在声明时使用“=0”来指定。</p>
<h2 id="3-c-的默认初始化、列表初始化、值初始化："><a href="#3-c-的默认初始化、列表初始化、值初始化：" class="headerlink" title="3.c++的默认初始化、列表初始化、值初始化："></a>3.c++的默认初始化、列表初始化、值初始化：</h2><p>初始化不是赋值，初始化的含义是创建变量时赋予一个初始值；赋值的含义是把对象的当前值擦除，而以一个新值代替。</p>
<ul>
<li>默认初始化</li>
</ul>
<p>如果定义变量时没有指定初值，则变量被默认初始化，变量被赋予默认值，值由自己的类型确定。</p>
<p>如果内置数据类型未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量不被初始化，则其值为未定义（未初始化的变量含有一个不确定的值）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数体外定义的变量会默认初始化</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> aa[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体内定义表的变量不会默认初始化</span></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> bb[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: aa )&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: bb )&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/image-20220514170125341.png" alt="image-20220514170125341"></p>
<p>绝大多数类支持无需显式初始化而定义对象，这样的类会为对象提供一个合适的默认值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string res;</span><br></pre></td></tr></table></figure>
<p>res非显式的初始化为一个空字符串。</p>
<p>一些类要求对象显式初始化，如果创建该类的一个对象却未显式初始化，会引发错误。</p>
<p>默认初始化创建一个指定类型的空vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure>
<p>在后续使用可以高效的添加元素</p>
<ul>
<li>列表初始化</li>
</ul>
<p>c++11提出的新标准，允许使用 用花括号括起来的 0个或多个初始元素 被赋予vector</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; s = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;aba&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h2><p>静态链接、动态链接</p>
<ul>
<li>静态链接</li>
</ul>
<p>链接时将需要用到的函数或过程链接到生成的可执行文件中，就算把静态库删除也不会影响到可执行程序的执行，生成的静态链接库，windows下以.lib为后缀，linux下以.a为后缀。</p>
<ul>
<li>动态链接</li>
</ul>
<p>链接的时候没有把需要用到的函数代码链接进去，而是在执行的过程中找要链接的函数，生成的可执行文件没有函数代码，只包含重定位信息，当你删除动态链接库后，可执行文件不能执行。动态链接库windows下为.dll，linux下为.so。</p>
<h2 id="5-include-lt-gt-和”-“的区别"><a href="#5-include-lt-gt-和”-“的区别" class="headerlink" title="5.include &lt;&gt;和” “的区别"></a>5.include &lt;&gt;和” “的区别</h2><ol>
<li>&lt;&gt;的头文件是系统文件，””的头文件是自定义文件</li>
<li>编译器预处理阶段的查找路径不一样</li>
</ol>
<p>查找路径</p>
<ul>
<li>&lt;&gt; 编译器设置的头文件路径-&gt;系统变量</li>
<li>“”当前头文件目录-&gt;编译器设置的头文件路径-&gt;系统变量</li>
</ul>
<h2 id="6-说说const和define的区别"><a href="#6-说说const和define的区别" class="headerlink" title="6.说说const和define的区别"></a>6.说说const和define的区别</h2><p>const用于定义常量</p>
<p>define用于定义宏，宏也可以用于定义常量</p>
<ol>
<li>const生效于编译的阶段，define生效于预处理阶段</li>
<li>const定义的常量，是c语言存储在内存中，需要额外内存空间的，define定义的常量在运行时直接是操作数，不会放在内存中。</li>
<li>const定义的常量是带类型的，define定义的常量是不带类型的，define定义的常量不利于类型检查。</li>
</ol>
<h2 id="7-const"><a href="#7-const" class="headerlink" title="7.const"></a>7.const</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;<span class="comment">//a是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;<span class="comment">//a是指向int常量的指针</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a;<span class="comment">//a是指向int常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;<span class="comment">//a是指向int的常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> a;<span class="comment">//a是指向常量int的常量指针</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> * 是常量指针</span><br><span class="line"></span><br><span class="line">* <span class="keyword">const</span> 是指针常量</span><br></pre></td></tr></table></figure>
<h2 id="8-lamda表达式"><a href="#8-lamda表达式" class="headerlink" title="8.lamda表达式"></a>8.lamda表达式</h2><ol>
<li><p>C++ 11 中的 Lambda 表达式用于定义并创建匿名的函数对象，用来简化编程工作。</p>
</li>
<li><p>Lambda 的语法形式：</p>
</li>
<li><p>[捕获列表] (参数列表) -&gt; 返回值类型 { 函数体 };</p>
</li>
</ol>
<p>o [捕获列表]：这部分是捕获区，用于捕获外部变量，标识一个 Lambda 表达式的开始，不能省略</p>
<p> 捕获列表为空：不捕获外部变量</p>
<p> =：表示值传入</p>
<p> &amp;：表示引用传入</p>
<p>示例：</p>
<p>[a]：将 a 按值进行传递</p>
<p>[&amp;a]：将 a 按引用进行传递。</p>
<p>[a,&amp;b]：将 a 按值传递，b 按引用进行传递。</p>
<p>[=,&amp;a,&amp;b]：除 a 和 b 按引用进行传递外，其它参数都按值进行传递。</p>
<p>[&amp;,a,b]：除 a 和 b 按值进行传递外，其它参数都按引用进行传递。</p>
<p>o (参数列表)：同函数参数列表</p>
<p>o -&gt; 返回值类型：这部分如果返回值为 void，可以省略</p>
<p>o { 函数体 }：同函数的函数体</p>
<h2 id="9-内联函数"><a href="#9-内联函数" class="headerlink" title="9.内联函数"></a>9.内联函数</h2><p>内联函数（inline），通常就是在每个调用点上“内联地”展开，内联函数的使用可以有效避免函数调用的开销。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> string &amp; <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> string &amp; s1,<span class="keyword">const</span> string &amp; s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>()?s1:s2;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联机制用于优化<strong>规模较小、流程直接、频繁调用</strong>的函数。</p>
<p>大多数编译器不支持<strong>内联递归函数</strong>。</p>
<h2 id="10-constexpr函数"><a href="#10-constexpr函数" class="headerlink" title="10.constexpr函数"></a>10.constexpr函数</h2><p>constexpr函数是指能用于常量表达式的函数，需要遵循以下几点原则；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr int new_sz()  &#123;return 42;&#125;</span><br><span class="line">constexpr int foo = new_sz;</span><br></pre></td></tr></table></figure>
<ol>
<li>函数返回值与形参类型必须是字面值类型</li>
<li>函数体中有且只有一条return语句</li>
<li>函数中也可由其他语句（空语句、类型别名、using声明），只要这些语句在运行时不执行其他操作。</li>
</ol>
<p>执行constexpr函数时，编译器会把函数调用替换为其结果值;为了能在编译过程随时展开，constexpr函数会被隐式的指定为内联函数。</p>
<p>允许constexpr函数的返回值并非一个常量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果arg是常量表达式，则scale(arg)也是常量表达式</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> </span>&#123; <span class="keyword">return</span> new_sz*cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)]; <span class="comment">//正确，scale(2)是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="built_in">scale</span>(<span class="number">2</span>)]; <span class="comment">//此处编译器报错，因为scale(2)不是常量表达式；而此处上下文需要scale返回一个常量表达式</span></span><br></pre></td></tr></table></figure>
<p>如果cnt是常量表达式，则返回值也是常量表达式；反之不然。</p>
<p>tips：通常把内联函数和constexpr函数放在头文件内（因为对于某个给定的内联函数或constexpr函数来说，可以在程序中多次定义，但它的多个定义必须完全一致）</p>
<ul>
<li>​    </li>
</ul>
<h1 id="B-内存"><a href="#B-内存" class="headerlink" title="B.内存"></a>B.内存</h1><h2 id="1-C-内存"><a href="#1-C-内存" class="headerlink" title="1.C++内存"></a>1.C++内存</h2><p><img src="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/798C7A2D023204559B62F88B54E35CBB.png" alt="img"></p>
<p><strong>一个程序有哪些section：</strong></p>
<p>如上图，<strong>从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等</strong>组成。</p>
<ol>
<li><strong>数据段：</strong>存放程序中已初始化的全局变量和静态变量的一块内存区域。</li>
<li><strong>代码段：</strong>存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</li>
<li><strong>BSS</strong> 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。</li>
</ol>
<p>存放未初始化或者初始化为0的全局变量和静态变量的一块内存区域，特点是可读写的。在程序执行前BSS段会自动清0。</p>
<ol>
<li><p>可执行程序在运行时又会多出两个区域：堆区和栈区。</p>
<p><strong>堆区：</strong>动态申请内存用。堆从低地址向高地址增长。</p>
<p><strong>栈区：</strong>存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</p>
</li>
<li><p>最后还有一个<strong>共享区</strong>，位于堆和栈之间。</p>
</li>
</ol>
<p><strong>程序启动的过程：</strong></p>
<ol>
<li>操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。</li>
<li>加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。</li>
<li>加载器针对该程序的每一个动态链接库调用LoadLibrary （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数</li>
<li>初始化应用程序的全局变量，对于全局对象自动调用构造函数。</li>
<li>进入应用程序入口点函数开始执行。</li>
</ol>
<p><strong>怎么判断数据分配在栈上还是堆上：</strong>首先局部变量分配在栈上；而通过malloc和new申请的空间是在堆上。</p>
<h1 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C.面向对象"></a>C.面向对象</h1><h2 id="1-多态"><a href="#1-多态" class="headerlink" title="1.多态"></a>1.多态</h2><p>使用基类的指针指向子类的对象，使用父类的指针调用子类的成员函数，实现多态。</p>
<p>包含重载、重写。</p>
<ol>
<li>多态是面向对象的重要特性之一，它是一种行为的封装，就是不同对象对同一行为会有不同的状态。(举例 : 学生和成人都去买票时,学生会打折,成人不会)</li>
<li>多态是以封装和继承为基础的。在C++中多态分为静态多态（早绑定）和动态多态（晚绑定）两种，其中动态多态是通过虚函数实现，静态多态通过函数重载实现。</li>
</ol>
<h2 id="2-虚函数"><a href="#2-虚函数" class="headerlink" title="2.虚函数"></a>2.虚函数</h2><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>
<ol>
<li>用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。</li>
<li>存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。</li>
<li>多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。</li>
<li>重写用虚函数来实现，结合动态绑定。</li>
<li>纯虚函数是虚函数再加上 = 0。</li>
<li>抽象类是指包括至少一个纯虚函数的类。</li>
</ol>
<p>纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。</p>
<h2 id="3-虚函数与纯虚函数的区别"><a href="#3-虚函数与纯虚函数的区别" class="headerlink" title="3.虚函数与纯虚函数的区别"></a>3.虚函数与纯虚函数的区别</h2><ol>
<li><p>只有虚函数的类不叫抽象类，但含有纯虚函数的类称为抽象类。</p>
</li>
<li><p>虚函数可以直接使用，被子类重写后可以以多态的形式调用；但纯虚函数不可以直接使用，因为其只有声明而没有定义。</p>
</li>
<li><p>虚函数和纯虚函数都可以在子类被重写，以多态的形式调用。</p>
</li>
<li><p>虚函数和纯虚函数通常存在于抽象基类中，被子类进行重写，目的是提供一个统一的接口。</p>
</li>
<li><p>虚函数定义 virtual{};纯虚函数定义virtual{}=0。</p>
<p>虚函数和纯虚函数不能有static修饰符，因为被static修饰的函数在编译前要求前期绑定，但虚函数是动态绑定。</p>
</li>
</ol>
<p>含有纯虚函数的类是抽象类，它不能生成对象，用户不能创建类的实例，只能创建其派生类的实例。</p>
<h2 id="4-c-中的构造函数"><a href="#4-c-中的构造函数" class="headerlink" title="4.c++中的构造函数"></a>4.c++中的构造函数</h2><p>默认构造函数</p>
<p>初始化构造函数</p>
<p>拷贝构造函数 复制构造函数默认的是浅拷贝</p>
<p>移动构造函数 将其他类型的变量隐式转为本类的对象</p>
<p>如果一个类定义了自己的析构函数，那么它要定义自己的拷贝构造函数和默认构造函数</p>
<h2 id="5-简述一下c-中的静态多态与动态多态"><a href="#5-简述一下c-中的静态多态与动态多态" class="headerlink" title="5.简述一下c++中的静态多态与动态多态"></a>5.简述一下c++中的静态多态与动态多态</h2><ul>
<li>静态多态在编译期间完成，编译器根据实参类型选择相应的重载函数。如果找到重载函数则执行，找不到则编译时报错。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Add</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span><span class="comment">//2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">Add</span>(<span class="number">666</span>,<span class="number">888</span>)&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">Add</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>);<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>动态多态</li>
</ul>
<p>通过基类的指针指向子类对象实现多态。</p>
<p>动态绑定2条件：</p>
<ol>
<li>虚函数，基类中必须有虚函数，在派生类中必须重写虚函数。</li>
<li>通过基类类型的指针引用来调用虚函数。</li>
</ol>
<h2 id="6-说说为什么要虚析构，为什么不能虚构造"><a href="#6-说说为什么要虚析构，为什么不能虚构造" class="headerlink" title="6.说说为什么要虚析构，为什么不能虚构造"></a>6.说说为什么要虚析构，为什么不能虚构造</h2><ol>
<li><p>虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。</p>
<ol>
<li>用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</li>
<li>用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。</li>
</ol>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
<p>（简单来说，虚析构函数可以使基类指针析构子类的对象，实现多态的特性）</p>
</li>
<li><p>不能虚构造：</p>
<ol>
<li>从存储空间角度：虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）</li>
<li>从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</li>
<li>从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</li>
</ol>
</li>
</ol>
<h2 id="7-定义析构函数会自动生成哪些函数"><a href="#7-定义析构函数会自动生成哪些函数" class="headerlink" title="7.定义析构函数会自动生成哪些函数"></a>7.定义析构函数会自动生成哪些函数</h2><p>只定义析构函数，编译器会自动生成拷贝构造函数和默认构造函数。</p>
<p>拷贝构造函数默认使用浅拷贝。</p>
<h2 id="8-一个类会默认生成哪些函数"><a href="#8-一个类会默认生成哪些函数" class="headerlink" title="8.一个类会默认生成哪些函数"></a>8.一个类会默认生成哪些函数</h2><p>定义一个空类，会默认生成以下函数：</p>
<p>1.无参构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Empty</span>(<span class="keyword">const</span> Empty&amp; copy)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.赋值运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Empty&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Empty&amp; copy)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.析构函数（非虚）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-说说c-类对象的初始化顺序"><a href="#9-说说c-类对象的初始化顺序" class="headerlink" title="9.说说c++类对象的初始化顺序"></a>9.说说c++类对象的初始化顺序</h2><p>父类构造函数–&gt;成员类对象构造函数–&gt;自身构造函数</p>
<p>其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。</p>
<p>析构顺序和构造顺序相反。</p>
<h2 id="10-简述浅拷贝和深拷贝"><a href="#10-简述浅拷贝和深拷贝" class="headerlink" title="10.简述浅拷贝和深拷贝"></a>10.简述浅拷贝和深拷贝</h2><ol>
<li>浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。</li>
<li>深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。</li>
<li>深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">STRING</span>( <span class="keyword">const</span> STRING&amp; s )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//_str = s._str;</span></span><br><span class="line">    _str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy_s</span>( _str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str );</span><br><span class="line">&#125;</span><br><span class="line">STRING&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> STRING&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//this-&gt;_str = s._str;</span></span><br><span class="line">        <span class="keyword">delete</span>[] _str;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s._str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy_s</span>(<span class="keyword">this</span>-&gt;_str, <span class="built_in">strlen</span>(s._str) + <span class="number">1</span>, s._str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象 ， 那么这里的赋值运算符的重载是怎么样做的呢？</p>
<p><img src="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/image-20220515104206498.png" alt="image-20220515104206498"></p>
<p>这种方法解决了我们的指针悬挂问题，通过不断的开空间让不同的指针指向不同的内存，以防止同一块内存被释放两次的问题。</p>
<h2 id="11-请你回答一下-C-类内可以定义引用数据成员吗？"><a href="#11-请你回答一下-C-类内可以定义引用数据成员吗？" class="headerlink" title="11.请你回答一下 C++ 类内可以定义引用数据成员吗？"></a>11.请你回答一下 C++ 类内可以定义引用数据成员吗？</h2><p>c++类内可以定义引用成员变量，但要遵循以下三个规则：</p>
<ol>
<li>不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。</li>
<li>构造函数的形参也必须是引用类型。</li>
<li>不能在构造函数里初始化，必须在初始化列表中进行初始化。</li>
</ol>
<h2 id="12-简述一下什么是常函数，有什么作用"><a href="#12-简述一下什么是常函数，有什么作用" class="headerlink" title="12.简述一下什么是常函数，有什么作用"></a>12.简述一下什么是常函数，有什么作用</h2><p>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。</p>
<p>在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。</p>
<p>除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">CStu</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//a = 13; //常函数不能修改数据成员</span></span><br><span class="line">        cout &lt;&lt;a &lt;&lt; <span class="string">&quot;I am show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CStu st;</span><br><span class="line">    st.<span class="built_in">Show</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-说说什么是虚继承，解决什么问题，如何实现？"><a href="#13-说说什么是虚继承，解决什么问题，如何实现？" class="headerlink" title="13.说说什么是虚继承，解决什么问题，如何实现？"></a>13.说说什么是虚继承，解决什么问题，如何实现？</h2><p>虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span><span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//菱形继承和菱形虚继承的对象模型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">1</span>;</span><br><span class="line">    d.C::_a = <span class="number">2</span>;</span><br><span class="line">    d._b = <span class="number">3</span>;</span><br><span class="line">    d._c = <span class="number">4</span>;</span><br><span class="line">    d._d = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(D) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别从菱形继承和虚继承来分析：</p>
<p><img src="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/1DBA188A576ED176E295873CC580363A.png" alt="img"></p>
<p>菱形继承中A在B,C,D,中各有一份，虚继承中，A共享（虚继承使得菱形继承共享一个基类对象）。</p>
<p>上面的虚继承表实际上是一个指针数组。B、C实际上是虚基表指针，指向虚基表。</p>
<p>虚基表：存放相对偏移量，用来找虚基类</p>
<p><img src="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.png" alt="未命名绘图"></p>
<h2 id="14-说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？"><a href="#14-说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？" class="headerlink" title="14.说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？"></a>14.说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？</h2><p><strong>参考回答</strong></p>
<ol>
<li><p>纯虚函数不可以实例化，但是可以用其派生类实例化，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> </span><br><span class="line">  <span class="keyword">public</span>:  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line"> &#125;; </span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>     </span><br><span class="line">  <span class="keyword">public</span>:     </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line">  <span class="keyword">public</span>:     </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;哈哈&quot;</span> &lt;&lt; endl;     </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">  Base *b = <span class="keyword">new</span> <span class="built_in">Derived</span>();     </span><br><span class="line">  b-&gt;<span class="built_in">func</span>();      </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。</p>
<p>即“纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”</p>
<p>所以纯虚函数不能实例化。</p>
</li>
<li><p>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。</p>
</li>
<li><p>定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p>
</li>
</ol>
<h2 id="15-请问拷贝构造函数的参数是什么传递方式，为什么"><a href="#15-请问拷贝构造函数的参数是什么传递方式，为什么" class="headerlink" title="15.请问拷贝构造函数的参数是什么传递方式，为什么"></a>15.请问拷贝构造函数的参数是什么传递方式，为什么</h2><p><strong>参考回答</strong></p>
<ol>
<li><p>拷贝构造函数的参数必须使用引用传递</p>
</li>
<li><p>如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。</p>
<p>需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。</p>
</li>
</ol>
<h2 id="16-如何理解抽象类？"><a href="#16-如何理解抽象类？" class="headerlink" title="16.如何理解抽象类？"></a>16.如何理解抽象类？</h2><p><strong>参考回答</strong></p>
<ol>
<li><p>抽象类的定义如下：</p>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有纯虚函数的类就叫做抽象类。</p>
</li>
<li><p>抽象类有如下几个特点：</p>
<p>1）抽象类只能用作其他类的基类，不能建立抽象类对象。</p>
<p>2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。</p>
<p>3）可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。</p>
</li>
</ol>
<h2 id="17-说说什么是虚基类，可否被实例化？"><a href="#17-说说什么是虚基类，可否被实例化？" class="headerlink" title="17.说说什么是虚基类，可否被实例化？"></a>17.说说什么是虚基类，可否被实例化？</h2><p><strong>参考回答</strong></p>
<ol>
<li><p>在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> A;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> A;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B1,<span class="keyword">public</span> B2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚继承的类可以被实例化，举例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Liger lg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*既然我们已经在Tiger和Lion类的定义中声明了&quot;virtual&quot;关键字，lg对象中只会有一个animal对象。于是下面的代码编译OK */</span></span><br><span class="line">    <span class="keyword">int</span> weight = lg.<span class="built_in">getWeight</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="18-简述一下拷贝赋值和移动赋值？"><a href="#18-简述一下拷贝赋值和移动赋值？" class="headerlink" title="18.简述一下拷贝赋值和移动赋值？"></a>18.简述一下拷贝赋值和移动赋值？</h2><p>   <strong>参考回答</strong></p>
<ol>
<li><p>拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。</p>
</li>
<li><p>移动赋值是通过移动构造函数来赋值，二者的主要区别在于</p>
<p>1）拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；</p>
<p>2）拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。</p>
</li>
</ol>
<h2 id="19-C-中哪些函数不能被声明为虚函数？"><a href="#19-C-中哪些函数不能被声明为虚函数？" class="headerlink" title="19.C++ 中哪些函数不能被声明为虚函数？"></a>19.C++ 中哪些函数不能被声明为虚函数？</h2><p><strong>参考回答</strong></p>
<p>常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。</p>
<ol>
<li><p>为什么C++不支持普通函数为虚函数？</p>
<p>普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。</p>
</li>
<li><p>为什么C++不支持构造函数为虚函数？</p>
<p>这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）</p>
<p>构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数</p>
</li>
<li><p>为什么C++不支持内联成员函数为虚函数？</p>
<p>其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，<em>inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数</em>）</p>
<p>内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数</p>
</li>
<li><p>为什么C++不支持静态成员函数为虚函数？</p>
<p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。</p>
<p>静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</p>
</li>
<li><p>为什么C++不支持友元函数为虚函数？</p>
<p>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</p>
</li>
</ol>
<h2 id="20-解释下-C-中类模板和模板类的区别"><a href="#20-解释下-C-中类模板和模板类的区别" class="headerlink" title="20.解释下 C++ 中类模板和模板类的区别"></a>20.解释下 C++ 中类模板和模板类的区别</h2><p><strong>参考回答</strong></p>
<ol>
<li>类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数</li>
<li>模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。</li>
</ol>
<p><strong>答案解析</strong></p>
<ol>
<li>类模板的类型参数可以有一个或多个，每个类型前面都必须加class，如template <class T1,class T2>class someclass{…};在定义对象时分别代入实际的类型名，如  someclass<int,double> obj;</li>
<li>和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。</li>
<li>模板可以有层次，一个类模板可以作为基类，派生出派生模板类。</li>
</ol>
<h2 id="21-虚函数表里存放的内容是什么时候写进去的？"><a href="#21-虚函数表里存放的内容是什么时候写进去的？" class="headerlink" title="21. 虚函数表里存放的内容是什么时候写进去的？"></a>21. 虚函数表里存放的内容是什么时候写进去的？</h2><p><strong>参考回答</strong></p>
<ol>
<li>虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vftable）在编译阶段生成，对象内存空间开辟以后，写入对象中的 vfptr，然后调用构造函数。即：虚表在构造函数之前写入</li>
<li>除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。</li>
</ol>
<h1 id="D-c-11新特性"><a href="#D-c-11新特性" class="headerlink" title="D. c++11新特性"></a>D. c++11新特性</h1><h2 id="1-说说-C-11-的新特性有哪些"><a href="#1-说说-C-11-的新特性有哪些" class="headerlink" title="1.说说 C++11 的新特性有哪些"></a>1.说说 C++11 的新特性有哪些</h2><p>  C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p>
<ol>
<li><p>语法的改进</p>
<p>（1）统一的初始化方法</p>
<p>（2）成员变量默认初始化</p>
<p>（3）auto关键字  用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）</p>
<p>（4）decltype  求表达式的类型</p>
<p>（5）智能指针 shared_ptr</p>
<p>（6）空指针 nullptr（原来NULL）</p>
<p>（7）基于范围的for循环</p>
<p>（8）右值引用和move语义  让程序员有意识减少进行深拷贝操作</p>
</li>
<li><p>标准库扩充（往STL里新加进一些模板类，比较好用）</p>
<p>（9）无序容器（哈希表）  用法和功能同map一模一样，区别在于哈希表的效率更高</p>
<p>（10）正则表达式  可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串</p>
<p>（11）Lambda表达式</p>
</li>
</ol>
<h2 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2.智能指针"></a>2.智能指针</h2><p>C++ 提供了四个智能指针模板类, 分别是: <code>auto_ptr</code>, <code>unique_ptr</code>, <code>shared_ptr</code>和<code>weak_ptr</code>. (<code>auto_ptr</code>是 C++98 提供的解决方案, C++11 已经将其摒弃, 并提供了另外三种解决方案). 这三个智能指针模板都定义了类似指针的对象, 可以将<code>new</code>获得(直接或间接)的地址赋给这种对象. <strong>当智能指针过期时, 其析构函数将使用<code>delete</code>来释放内存.</strong> (要创建智能指针对象, 需要包含头文件<code>&lt;memory&gt;</code>)</p>
<h3 id="1-三种智能指针的区别"><a href="#1-三种智能指针的区别" class="headerlink" title="1.三种智能指针的区别?"></a>1.三种智能指针的区别?</h3><ul>
<li>auto_ptr: 当进行赋值时, 会将旧指针的所有权转让, 使得 <strong>对于特定的对象, 只能有一个智能指针可以拥有它</strong>.（c++11已摒弃）</li>
<li>unique_ptr: 当进行赋值时, 会将旧指针的所有权转让, 使得 <strong>对于特定的对象, 只能有一个智能指针可以拥有它</strong>. unique_ptr 相比于 auto_ptr 会执行更加严格的所有权转让策略</li>
<li>shared_ptr: 通过引用计数(reference counting), 跟踪引用特定特定对象的智能指针数. 当发生赋值操作时, 计数增1, 当指针过期时, 计数减1. 仅当最后一个指针过期时, 才调用 delete.</li>
<li>weak_ptr: 不控制对象声明周期的智能指针, 它指向一个 shared_ptr 管理的对象, 而进行内存管理的只有 shared_ptr. weak_ptr 主要用来帮助解决循环引用问题, 它的构造和析构不会引起引用计数的增加或者减少. weak_ptr 一般都是配合 shared_ptr 使用, 通常不会单独使用.</li>
</ul>
<h3 id="2-unique-ptr-和-auto-ptr-的区别"><a href="#2-unique-ptr-和-auto-ptr-的区别" class="headerlink" title="2.unique_ptr 和 auto_ptr 的区别?"></a>2.unique_ptr 和 auto_ptr 的区别?</h3><ul>
<li><p>所有权转让机制不同: auto_ptr 允许通过直接赋值进行转让, 但是这样会留下危险的 <strong>悬挂指针</strong>, 容易使得程序在运行阶段崩溃. unique_ptr 仅仅允许将临时右值进行赋值, 否则会在编译阶段发生错误, 这样更加安全(编译阶段错误比潜在的程序崩溃更安全).</p>
</li>
<li><p>相比于 auto_ptr 和 share_ptr, unique_ptr 可以使用<code>new[]</code>分配的内存作为参数: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">double</span>[]&gt; <span class="title">pda</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">5</span>))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-如何选择合适的智能指针"><a href="#3-如何选择合适的智能指针" class="headerlink" title="3.如何选择合适的智能指针?"></a>3.如何选择合适的智能指针?</h3><p>如果程序要使用多个指向同一个对象的指针, 应选择<code>shared_ptr</code>, 这样的情况包括:</p>
<ul>
<li>对于智能指针数组, 用辅助指针来标识最大值或最小值的情况</li>
<li>很多 STL 算法都支持复制和赋值操作, 这些操作可用于 <code>shared_ptr</code>, 但不能用于 <code>unique_ptr</code> 和 <code>auto_ptr</code>.</li>
</ul>
<p>如果程序不需要多个指向同一个对象的指针, 则可以使用<code>unique_ptr</code>, 如果函数使用<code>new</code>分配内存, 并返回指向该内存的指针, 将其返回类型声明为<code>unique_ptr</code>是不错的选择, 这样, 所有权将转让给接受返回值的<code>unique_ptr</code>.</p>
<h2 id="3-无序容器（哈希表）"><a href="#3-无序容器（哈希表）" class="headerlink" title="3.无序容器（哈希表）"></a>3.无序容器（哈希表）</h2><p>无序容器（哈希表）  </p>
<p>用法和功能同map一模一样，区别在于哈希表的效率更高。</p>
<p>(1) 无序容器具有以下 2 个特点：</p>
<p>  a. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</p>
<p>  b. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</p>
<p>(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：</p>
<p><img src="https://fisherpics.oss-cn-beijing.aliyuncs.com/imgs/%E6%88%AA%E5%B1%8F2022-05-22%2016.29.46.png" alt="截屏2022-05-22 16.29.46"></p>
<h2 id="3-正则表达式"><a href="#3-正则表达式" class="headerlink" title="3.正则表达式"></a>3.正则表达式</h2><p>可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配行的开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配行的结尾</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意单个字符</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配[]中的任意一个字符</td>
</tr>
<tr>
<td>(…)</td>
<td>设定分组</td>
</tr>
<tr>
<td>\</td>
<td>转义字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>\d 取反</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母[a-z]，数字，下划线</td>
</tr>
<tr>
<td>\W</td>
<td>\w 取反</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空格</td>
</tr>
<tr>
<td>\S</td>
<td>\s 取反</td>
</tr>
<tr>
<td>+</td>
<td>前面的元素重复1次或多次</td>
</tr>
<tr>
<td>*</td>
<td>前面的元素重复任意次</td>
</tr>
<tr>
<td>?</td>
<td>前面的元素重复0次或1次</td>
</tr>
<tr>
<td>{n}</td>
<td>前面的元素重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>前面的元素重复至少n次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>前面的元素重复至少n次，至多m次</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>逻辑或</td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-Lambda匿名函数"><a href="#5-Lambda匿名函数" class="headerlink" title="5.Lambda匿名函数"></a>5.Lambda匿名函数</h2><p>所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</p>
<h3 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h3><p>  lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<p>​    [外部变量访问方式说明符] (参数) mutable noexcept/throw() -&gt; 返回值类型     {      函数体;     };</p>
<p>其中各部分的含义分别为：</p>
<p>a. [外部变量方位方式说明符]   [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。</p>
<p>  所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</p>
<p>b. (参数)   和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p>
<p>c. mutable   此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p>
<p>  <strong>注意:</strong>对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p>
<p>d. noexcept/throw()   可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</p>
<p>e. -&gt; 返回值类型   指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略”-&gt; 返回值类型”。</p>
<p>f. 函数体   和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p>
<h3 id="（2）程序实例"><a href="#（2）程序实例" class="headerlink" title="（2）程序实例"></a>（2）程序实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num+<span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    程序运行结果：</span></span><br><span class="line"><span class="comment">          1 2 3 4</span></span><br><span class="line"><span class="comment">*/</span>            </span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c-%E7%AC%94%E8%AE%B0/" rel="tag"># c++笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="prev" title="字符串类算法笔记">
      <i class="fa fa-chevron-left"></i> 字符串类算法笔记
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



            </div>
            

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

          </div>
            
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">c++学习笔记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#A-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">A.语法基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%8F%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">2.1.</span> <span class="nav-text">1.宏定义：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-C-%E6%8E%A5%E5%8F%A3%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">2.C++ 接口（抽象类）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-c-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><span class="nav-number">2.3.</span> <span class="nav-text">3.c++的默认初始化、列表初始化、值初始化：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%93%BE%E6%8E%A5"><span class="nav-number">2.4.</span> <span class="nav-text">4.链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-include-lt-gt-%E5%92%8C%E2%80%9D-%E2%80%9C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.5.</span> <span class="nav-text">5.include &lt;&gt;和” “的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%AF%B4%E8%AF%B4const%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.6.</span> <span class="nav-text">6.说说const和define的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-const"><span class="nav-number">2.7.</span> <span class="nav-text">7.const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.8.</span> <span class="nav-text">8.lamda表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">2.9.</span> <span class="nav-text">9.内联函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-constexpr%E5%87%BD%E6%95%B0"><span class="nav-number">2.10.</span> <span class="nav-text">10.constexpr函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E5%86%85%E5%AD%98"><span class="nav-number">3.</span> <span class="nav-text">B.内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-C-%E5%86%85%E5%AD%98"><span class="nav-number">3.1.</span> <span class="nav-text">1.C++内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.</span> <span class="nav-text">C.面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A4%9A%E6%80%81"><span class="nav-number">4.1.</span> <span class="nav-text">1.多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">2.虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.</span> <span class="nav-text">3.虚函数与纯虚函数的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-c-%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">4.c++中的构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8Bc-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81"><span class="nav-number">4.5.</span> <span class="nav-text">5.简述一下c++中的静态多态与动态多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E6%9E%90%E6%9E%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%99%9A%E6%9E%84%E9%80%A0"><span class="nav-number">4.6.</span> <span class="nav-text">6.说说为什么要虚析构，为什么不能虚构造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%AE%9A%E4%B9%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-number">4.7.</span> <span class="nav-text">7.定义析构函数会自动生成哪些函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%9A%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-number">4.8.</span> <span class="nav-text">8.一个类会默认生成哪些函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E8%AF%B4%E8%AF%B4c-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.9.</span> <span class="nav-text">9.说说c++类对象的初始化顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E7%AE%80%E8%BF%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">4.10.</span> <span class="nav-text">10.简述浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8B-C-%E7%B1%BB%E5%86%85%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F"><span class="nav-number">4.11.</span> <span class="nav-text">11.请你回答一下 C++ 类内可以定义引用数据成员吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%B8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">4.12.</span> <span class="nav-text">12.简述一下什么是常函数，有什么作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">4.13.</span> <span class="nav-text">13.说说什么是虚继承，解决什么问题，如何实现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E8%AF%B4%E8%AF%B4%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.14.</span> <span class="nav-text">14.说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E8%AF%B7%E9%97%AE%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">4.15.</span> <span class="nav-text">15.请问拷贝构造函数的参数是什么传递方式，为什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9F"><span class="nav-number">4.16.</span> <span class="nav-text">16.如何理解抽象类？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%9F%BA%E7%B1%BB%EF%BC%8C%E5%8F%AF%E5%90%A6%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9F"><span class="nav-number">4.17.</span> <span class="nav-text">17.说说什么是虚基类，可否被实例化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%EF%BC%9F"><span class="nav-number">4.18.</span> <span class="nav-text">18.简述一下拷贝赋值和移动赋值？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-C-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">4.19.</span> <span class="nav-text">19.C++ 中哪些函数不能被声明为虚函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E8%A7%A3%E9%87%8A%E4%B8%8B-C-%E4%B8%AD%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.20.</span> <span class="nav-text">20.解释下 C++ 中类模板和模板类的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E9%87%8C%E5%AD%98%E6%94%BE%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%86%99%E8%BF%9B%E5%8E%BB%E7%9A%84%EF%BC%9F"><span class="nav-number">4.21.</span> <span class="nav-text">21. 虚函数表里存放的内容是什么时候写进去的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#D-c-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">D. c++11新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AF%B4%E8%AF%B4-C-11-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">5.1.</span> <span class="nav-text">1.说说 C++11 的新特性有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">5.2.</span> <span class="nav-text">2.智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%89%E7%A7%8D%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.1.</span> <span class="nav-text">1.三种智能指针的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-unique-ptr-%E5%92%8C-auto-ptr-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.2.</span> <span class="nav-text">2.unique_ptr 和 auto_ptr 的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">5.2.3.</span> <span class="nav-text">3.如何选择合适的智能指针?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="nav-number">5.3.</span> <span class="nav-text">3.无序容器（哈希表）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">3.正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.</span> <span class="nav-text">5.Lambda匿名函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AE%9A%E4%B9%89"><span class="nav-number">5.5.1.</span> <span class="nav-text">（1）定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BE%8B"><span class="nav-number">5.5.2.</span> <span class="nav-text">（2）程序实例</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fisher Yu"
      src="/images/fisher.jpg">
  <p class="site-author-name" itemprop="name">Fisher Yu</p>
  <div class="site-description" itemprop="description">学习过程中的一些浅显summries,见谅!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        </div>
      </main>

      <footer class="footer">
        <div class="footer-inner">
          

          

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fisher Yu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">63k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">57 分钟</span>



</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


          
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        </div>
      </footer>
    </div>
  


  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true}});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/schemes/click.js"></script>

